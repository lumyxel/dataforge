import 'dart:io';
import 'package:test/test.dart';
import 'package:path/path.dart' as path;
import 'package:dataforge/dataforge.dart';

/// 代码生成器测试模块
/// 包含：端到端生成测试
void runGeneratorTests() {
  group('Data Class Generator Tests', () {
    late Directory tempDir;
    late File testFile;
    late File outputFile;

    setUp(() {
      tempDir = Directory.systemTemp.createTempSync('generator_test_');
      testFile = File(path.join(tempDir.path, 'test.model.dart'));
      outputFile = File(path.join(tempDir.path, 'test.model.data.dart'));
    });

    tearDown(() {
      if (tempDir.existsSync()) {
        tempDir.deleteSync(recursive: true);
      }
    });

    test('should detect model files correctly', () {
      // Create a model file
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

@Dataforge()
class TestModel {
  final String name;
  final int age;
  
  const TestModel({
    required this.name,
    required this.age,
  });
}

/// Main function for standalone test execution
void main() {
  runGeneratorTests();
}
''');

      // Create a non-model file
      final nonModelFile = File(path.join(tempDir.path, 'regular.dart'));
      nonModelFile.writeAsStringSync('''
class RegularClass {
  final String value;
  const RegularClass(this.value);
}
''');

      expect(testFile.existsSync(), isTrue);
      expect(nonModelFile.existsSync(), isTrue);
      expect(testFile.path.endsWith('.model.dart'), isTrue);
      expect(nonModelFile.path.endsWith('.model.dart'), isFalse);
    });

    test('should generate code for simple model', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class SimpleModel {
  final String name;
  final int value;
  
  const SimpleModel({
    required this.name,
    required this.value,
  });
}
''');

      // Run code generation
      await generate(tempDir.path);

      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      expect(content, contains('Generated by data class generator'));
      expect(content, contains('mixin _SimpleModel'));
      expect(content, contains('toJson()'));
      expect(content, contains('fromJson('));
      expect(content, contains('call({'));
      expect(content, contains('toString()'));
      expect(content, contains('operator ==('));
      expect(content, contains('hashCode'));
    });

    test('should generate code for complex model with various types', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class ComplexModel {
  final String name;
  final int age;
  final double height;
  final bool isActive;
  final List<String> tags;
  final Map<String, dynamic> metadata;
  final DateTime? createdAt;
  
  const ComplexModel({
    required this.name,
    required this.age,
    required this.height,
    required this.isActive,
    required this.tags,
    required this.metadata,
    this.createdAt,
  });
}
''');

      await generate(tempDir.path);

      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      expect(content, contains('mixin _ComplexModel'));
      expect(content, contains('abstract final String name'));
      expect(content, contains('abstract final int age'));
      expect(content, contains('abstract final double height'));
      expect(content, contains('abstract final bool isActive'));
      expect(content, contains('abstract final List<String> tags'));
      expect(content, contains('abstract final Map<String, dynamic> metadata'));
      expect(content, contains('abstract final DateTime? createdAt'));
    });

    test('should handle models with converters', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class ModelWithConverters {
  @DateTimeConverter()
  final DateTime createdAt;
  
  @DateTimeMillisecondsConverter()
  final DateTime updatedAt;
  
  @DurationConverter()
  final Duration timeout;
  
  const ModelWithConverters({
    required this.createdAt,
    required this.updatedAt,
    required this.timeout,
  });
}
''');

      await generate(tempDir.path);

      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      expect(content, contains('mixin _ModelWithConverters'));
      expect(content, contains('DateTime'));
      expect(content, contains('Duration'));
    });

    test('should handle models with ignored fields', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class ModelWithIgnoredFields {
  final String name;
  
  @ignore
  final String? password;
  
  @ignore
  final String? secretToken;
  
  final int age;
  
  const ModelWithIgnoredFields({
    required this.name,
    this.password,
    this.secretToken,
    required this.age,
  });
}
''');

      await generate(tempDir.path);

      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      expect(content, contains('mixin _ModelWithIgnoredFields'));
      expect(content, contains('abstract final String name'));
      expect(content, contains('abstract final int age'));
      expect(content, contains('map[\'name\'] = name'));
      expect(content, contains('map[\'age\'] = age'));
      expect(content,
          isNot(contains('map[\'password\']'))); // Should not be in toJson
      expect(content,
          isNot(contains('map[\'secretToken\']'))); // Should not be in toJson
    });

    test('should handle models with alternate names', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class ModelWithAlternateNames {
  @alternateNames(['user_name', 'username'])
  final String name;
  
  @alternateNames(['user_age'])
  final int age;
  
  const ModelWithAlternateNames({
    required this.name,
    required this.age,
  });
}
''');

      await generate(tempDir.path);

      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      expect(content, contains('mixin _ModelWithAlternateNames'));
      expect(content, contains('name'));
      expect(content, contains('age'));
    });

    test('should format generated code correctly', () async {
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class FormattingTest {
  final String name;
  final int value;
  
  const FormattingTest({
    required this.name,
    required this.value,
  });
}
''');

      await generate(tempDir.path);

      // Run dart format on the generated file
      final formatResult = await Process.run(
        'dart',
        ['format', outputFile.path],
      );

      expect(formatResult.exitCode, equals(0));
      expect(outputFile.existsSync(), isTrue);

      final content = outputFile.readAsStringSync();
      // Check that the code is properly formatted (basic structure checks)
      expect(content, contains('mixin _FormattingTest'));
      expect(content, contains('abstract final String name'));
      expect(content, contains('abstract final int value'));
      // Check that the code has proper structure
      expect(content, contains('call({'));
      expect(content, contains('toJson()'));
      expect(content, contains('fromJson('));
    });

    test('should handle multiple models in same directory', () async {
      // Create first model
      testFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'test.model.data.dart';

@Dataforge()
class FirstModel {
  final String name;
  
  const FirstModel({required this.name});
}
''');

      // Create second model
      final secondTestFile = File(path.join(tempDir.path, 'second.model.dart'));
      secondTestFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'second.model.data.dart';

@Dataforge()
class SecondModel {
  final int value;
  
  const SecondModel({required this.value});
}
''');

      await generate(tempDir.path);

      final firstOutputFile =
          File(path.join(tempDir.path, 'test.model.data.dart'));
      final secondOutputFile =
          File(path.join(tempDir.path, 'second.model.data.dart'));

      expect(firstOutputFile.existsSync(), isTrue);
      expect(secondOutputFile.existsSync(), isTrue);

      final firstContent = firstOutputFile.readAsStringSync();
      final secondContent = secondOutputFile.readAsStringSync();

      expect(firstContent, contains('mixin _FirstModel'));
      expect(secondContent, contains('mixin _SecondModel'));
    });

    test('should handle nested directory structure', () async {
      // Create nested directory
      final nestedDir = Directory(path.join(tempDir.path, 'nested', 'models'));
      nestedDir.createSync(recursive: true);

      final nestedTestFile =
          File(path.join(nestedDir.path, 'nested.model.dart'));
      nestedTestFile.writeAsStringSync('''
import 'package:dataforge_annotation/dataforge_annotation.dart';

part 'nested.model.data.dart';

@Dataforge()
class NestedModel {
  final String data;
  
  const NestedModel({required this.data});
}
''');

      await generate(tempDir.path);

      final nestedOutputFile =
          File(path.join(nestedDir.path, 'nested.model.data.dart'));
      expect(nestedOutputFile.existsSync(), isTrue);

      final content = nestedOutputFile.readAsStringSync();
      expect(content, contains('mixin _NestedModel'));
    });
  });
}

/// Main function for standalone test execution
void main() {
  runGeneratorTests();
}
