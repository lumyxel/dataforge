import 'dart:io';
import 'package:test/test.dart';
import 'package:dataforge/dataforge.dart';
import 'package:path/path.dart' as p;
import 'models/default_values.model.dart';

/// Data class generator tests
///
/// Test logic:
/// 1. Create test models
/// 2. Run code generation script
/// 3. Execute dart fix and dart format for code formatting
/// 4. Verify generated code meets expectations
void main() {
  group('Data Class Generator Tests', () {
    late Directory testModelsDir;

    setUpAll(() {
      testModelsDir = Directory('test/models');
      if (!testModelsDir.existsSync()) {
        testModelsDir.createSync(recursive: true);
      }
    });

    test('should generate code for existing models',
        timeout: Timeout(Duration(minutes: 2)), () async {
      // 1. Verify test models exist
      final allDartFiles = testModelsDir
          .listSync()
          .where((file) =>
              file.path.endsWith('.dart') && !file.path.endsWith('.data.dart'))
          .cast<File>()
          .toList();

      // Filter files that contain @dataforge or @Dataforge annotations
      final modelFiles = <File>[];
      for (final file in allDartFiles) {
        final content = file.readAsStringSync();
        if (content.contains('@dataforge') || content.contains('@Dataforge')) {
          modelFiles.add(file);
        }
      }

      expect(modelFiles.isNotEmpty, isTrue,
          reason: 'Should have at least one model file');

      // 2. Run code generation
      print('Running code generation...');
      final generateResult = await Process.run(
          'dart', ['bin/dataforge.dart', 'test/models'],
          workingDirectory: Directory.current.path);
      expect(generateResult.exitCode, equals(0),
          reason: 'Code generation should succeed');
      print('Code generation completed: ${generateResult.stdout}');

      // 3. Execute code formatting
      print('Running dart fix...');
      final fixResult = await Process.run('dart', ['fix', '--apply'],
          workingDirectory: Directory.current.path);
      expect(fixResult.exitCode, equals(0), reason: 'dart fix should succeed');

      print('Running dart format...');
      final formatResult = await Process.run('dart', ['format', 'test/models'],
          workingDirectory: Directory.current.path);
      expect(formatResult.exitCode, equals(0),
          reason: 'dart format should succeed');

      // 4. Verify generated code
      for (final modelFile in modelFiles) {
        final baseName = p.basenameWithoutExtension(modelFile.path);
        final generatedFile =
            File(p.join('test/models', '$baseName.data.dart'));

        expect(generatedFile.existsSync(), isTrue,
            reason: 'Generated file should exist for ${modelFile.path}');

        // First verify generated code has no syntax errors
        // print('Checking syntax for $baseName.data.dart...');
        // final analyzeResult = await Process.run(
        //     'dart', ['analyze', '--no-fatal-warnings', generatedFile.path],
        //     workingDirectory: Directory.current.path);

        // if (analyzeResult.exitCode != 0) {
        //   print('Analyze stdout: ${analyzeResult.stdout}');
        //   print('Analyze stderr: ${analyzeResult.stderr}');
        //   fail('Generated file ${generatedFile.path} has syntax errors');
        // }

        final generatedContent = generatedFile.readAsStringSync();

        // Verify generated code contains necessary content
        expect(
            generatedContent, contains('// Generated by data class generator'));
        expect(generatedContent, contains('// DO NOT MODIFY BY HAND'));
        expect(generatedContent, contains('mixin'));

        print('âœ“ Generated code verified for $baseName (syntax and content)');
      }
    });

    test('should generate syntactically valid Dart code', () async {
      // Verify generated code can be parsed by Dart compiler (validate syntax through dart format)
      print('Verifying generated code syntax...');
      final formatResult = await Process.run(
          'dart', ['format', '--set-exit-if-changed', 'test/models'],
          workingDirectory: Directory.current.path);

      // If dart format can run successfully, it means the syntax is correct
      // We don't care about format changes, only whether syntax is correct
      if (formatResult.exitCode != 0 && formatResult.exitCode != 1) {
        print('Format stdout: ${formatResult.stdout}');
        print('Format stderr: ${formatResult.stderr}');
        fail('Generated code has syntax errors');
      }

      print('âœ“ Generated code syntax is valid');
    });

    test('should generate code with expected methods', () {
      final testModelFile = File('test/models/test_model.dart');
      if (testModelFile.existsSync()) {
        final generatedFile = File('test/models/test_model.data.dart');
        expect(generatedFile.existsSync(), isTrue);

        final content = generatedFile.readAsStringSync();

        // Verify generated methods
        expect(content, contains('copyWith('),
            reason: 'Should contain copyWith method');
        expect(content, contains('operator ==('),
            reason: 'Should contain equality operator');
        expect(content, contains('get hashCode'),
            reason: 'Should contain hashCode getter');
        expect(content, contains('toJson()'),
            reason: 'Should contain toJson method');
        expect(content, contains('fromJson('),
            reason: 'Should contain fromJson method');
        expect(content, contains('toString()'),
            reason: 'Should contain toString method');

        print('âœ“ All expected methods found in generated code');
      }
    });

    test('should handle JsonKey annotations correctly', () {
      final jsonKeyFile =
          File('test/models/json_key_functions_test.model.dart');
      if (jsonKeyFile.existsSync()) {
        final jsonKeyContent = jsonKeyFile.readAsStringSync();
        final generatedFile =
            File('test/models/json_key_functions_test.model.data.dart');

        if (jsonKeyContent.contains('@JsonKey') && generatedFile.existsSync()) {
          final generatedContent = generatedFile.readAsStringSync();

          // If original file contains JsonKey annotations, generated code should handle field mapping correctly
          expect(generatedContent, contains("map["),
              reason: 'Should use JsonKey field mapping');

          print('âœ“ JsonKey annotations handled correctly');
        }
      }
    });

    test('should generate working factory fromJson methods', () {
      // Test factory fromJson methods for all model classes
      print('Testing factory fromJson methods...');

      // Dynamically import and test EnumTypes
      final enumTypesFile = File('test/models/enum_types.model.dart');
      if (enumTypesFile.existsSync()) {
        final enumTypesContent = enumTypesFile.readAsStringSync();
        expect(enumTypesContent, contains('factory EnumTypes.fromJson'),
            reason: 'EnumTypes should have factory fromJson method');
        print('âœ“ EnumTypes has factory fromJson method');
      }

      // Test Address (nested_objects.model.dart)
      final nestedObjectsFile = File('test/models/nested_objects.model.dart');
      if (nestedObjectsFile.existsSync()) {
        final nestedObjectsContent = nestedObjectsFile.readAsStringSync();
        expect(nestedObjectsContent, contains('factory Address.fromJson'),
            reason: 'Address should have factory fromJson method');
        expect(nestedObjectsContent, contains('factory Contact.fromJson'),
            reason: 'Contact should have factory fromJson method');
        expect(nestedObjectsContent, contains('factory Company.fromJson'),
            reason: 'Company should have factory fromJson method');
        expect(nestedObjectsContent, contains('factory NestedObjects.fromJson'),
            reason: 'NestedObjects should have factory fromJson method');
        print('âœ“ All nested object classes have factory fromJson methods');
      }

      // Test DateTimeTypes
      final dateTimeTypesFile = File('test/models/datetime_types.model.dart');
      if (dateTimeTypesFile.existsSync()) {
        final dateTimeTypesContent = dateTimeTypesFile.readAsStringSync();
        expect(dateTimeTypesContent, contains('factory DateTimeTypes.fromJson'),
            reason: 'DateTimeTypes should have factory fromJson method');
        expect(dateTimeTypesContent, contains('factory TimeZoneTest.fromJson'),
            reason: 'TimeZoneTest should have factory fromJson method');
        print('âœ“ All datetime classes have factory fromJson methods');
      }

      // Test CustomReadValue
      final customReadValueFile =
          File('test/models/custom_read_value.model.dart');
      if (customReadValueFile.existsSync()) {
        final customReadValueContent = customReadValueFile.readAsStringSync();
        expect(customReadValueContent,
            contains('factory CustomReadValue.fromJson'),
            reason: 'CustomReadValue should have factory fromJson method');
        print('âœ“ CustomReadValue has factory fromJson method');
      }

      // Test MapTypes
      final mapTypesFile = File('test/models/map_types.model.dart');
      if (mapTypesFile.existsSync()) {
        final mapTypesContent = mapTypesFile.readAsStringSync();
        expect(mapTypesContent, contains('factory MapTypes.fromJson'),
            reason: 'MapTypes should have factory fromJson method');
        expect(mapTypesContent, contains('factory MapWithObjects.fromJson'),
            reason: 'MapWithObjects should have factory fromJson method');
        print('âœ“ All map classes have factory fromJson methods');
      }

      print('ðŸŽ‰ All model classes have working factory fromJson methods!');
    });

    test('should use default values when fromJson receives empty map',
        () async {
      // Generate the data class first
      generate('test/models');

      // Verify the generated file exists
      final generatedFile = File('test/models/default_values.model.data.dart');
      expect(generatedFile.existsSync(), isTrue,
          reason: 'Generated file should exist');

      // Test that calling fromJson({}) uses constructor defaults
      final defaultValues = DefaultValues.fromJson({});
      final nestedDefaultValues = NestedDefaultValues.fromJson({});

      // Verify DefaultValues default values
      expect(defaultValues.intValue, equals(42),
          reason: 'intValue should use default value 42');
      expect(defaultValues.stringValue, equals('default'),
          reason: 'stringValue should use default value "default"');
      expect(defaultValues.boolValue, equals(true),
          reason: 'boolValue should use default value true');
      expect(defaultValues.doubleValue, equals(3.14),
          reason: 'doubleValue should use default value 3.14');
      expect(defaultValues.listValue, equals(['default']),
          reason: 'listValue should use default value ["default"]');

      // Verify NestedDefaultValues default values
      expect(nestedDefaultValues.name, equals('nested_default'),
          reason: 'name should use default value "nested_default"');
      expect(nestedDefaultValues.nullableValue, isNull,
          reason: 'nullableValue should be null by default');
      expect(nestedDefaultValues.nested.intValue, equals(42),
          reason: 'nested DefaultValues should use default intValue 42');

      print('âœ“ fromJson({}) correctly uses constructor default values');
    });

    test('should handle default values correctly in fromJson', () {
      // Directly test default value functionality of fromJson({}) method
      print('Testing default values functionality by calling fromJson({})...');

      final defaultValuesFile = File('test/models/default_values.model.dart');
      if (defaultValuesFile.existsSync()) {
        final defaultValuesContent = defaultValuesFile.readAsStringSync();
        expect(defaultValuesContent, contains('factory DefaultValues.fromJson'),
            reason: 'DefaultValues should have factory fromJson method');
        expect(defaultValuesContent,
            contains('factory NestedDefaultValues.fromJson'),
            reason: 'NestedDefaultValues should have factory fromJson method');
        print('âœ“ Default values classes have factory fromJson methods');

        // Verify generated code file exists
        final generatedFile =
            File('test/models/default_values.model.data.dart');
        if (generatedFile.existsSync()) {
          print('âœ“ Generated default_values.data.dart file exists');

          // Import generated class and directly test fromJson({})
          // Note: Here we verify default value logic is correctly implemented by checking generated code
          final generatedContent = generatedFile.readAsStringSync();

          // Verify DefaultValues.fromJson({}) will use default values
          expect(generatedContent, contains('?? 42'),
              reason: 'intValue should fallback to default value 42');
          expect(generatedContent, contains("?? 'default'"),
              reason: 'stringValue should fallback to default value');
          expect(generatedContent, contains('?? true'),
              reason: 'boolValue should fallback to default value true');
          expect(generatedContent, contains('?? 3.14'),
              reason: 'doubleValue should fallback to default value 3.14');
          expect(generatedContent, contains("?? const ['default']"),
              reason: 'listValue should use default list value');

          // Verify NestedDefaultValues.fromJson({}) will use default values
          expect(generatedContent, contains("?? 'nested_default'"),
              reason: 'name should fallback to default value');
          expect(generatedContent, contains('const DefaultValues()'),
              reason: 'nested should use default constructor');

          print(
              'âœ“ fromJson({}) will correctly apply all constructor default values');
          print('âœ“ Default values functionality verified successfully');
        }
      }
    });

    test('should generate working toString method', () async {
      // Generate the data class first
      generate('test/models');

      // Test toString method functionality
      print('Testing toString method functionality...');

      // Test DefaultValues toString
      final defaultValues = DefaultValues(
        intValue: 100,
        stringValue: 'test',
        boolValue: false,
        doubleValue: 2.5,
        listValue: ['a', 'b'],
      );

      final defaultValuesToString = defaultValues.toString();
      expect(defaultValuesToString, contains('DefaultValues('),
          reason: 'toString should start with class name');
      expect(defaultValuesToString, contains('intValue: 100'),
          reason: 'toString should contain intValue field');
      expect(defaultValuesToString, contains('stringValue: test'),
          reason: 'toString should contain stringValue field');
      expect(defaultValuesToString, contains('boolValue: false'),
          reason: 'toString should contain boolValue field');
      expect(defaultValuesToString, contains('doubleValue: 2.5'),
          reason: 'toString should contain doubleValue field');
      expect(defaultValuesToString, contains('listValue: [a, b]'),
          reason: 'toString should contain listValue field');

      print('âœ“ DefaultValues toString: $defaultValuesToString');

      // Test NestedDefaultValues toString
      final nestedDefaultValues = NestedDefaultValues(
        name: 'test_nested',
        nullableValue: 123,
        nested: DefaultValues(intValue: 50, stringValue: 'nested_test'),
      );

      final nestedToString = nestedDefaultValues.toString();
      expect(nestedToString, contains('NestedDefaultValues('),
          reason: 'toString should start with class name');
      expect(nestedToString, contains('name: test_nested'),
          reason: 'toString should contain name field');
      expect(nestedToString, contains('nullableValue: 123'),
          reason: 'toString should contain nullableValue field');
      expect(nestedToString, contains('nested: DefaultValues('),
          reason: 'toString should contain nested object');

      print('âœ“ NestedDefaultValues toString: $nestedToString');
      print('âœ“ toString method functionality verified successfully');
    });
  });
}
