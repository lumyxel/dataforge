// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'datetime_types.model.dart';

mixin _DateTimeTypes {
  abstract final DateTime createdAt;
  abstract final DateTime? updatedAt;
  abstract final DateTime birthDate;
  abstract final List<DateTime> eventDates;
  abstract final List<DateTime>? optionalEventDates;
  abstract final Map<String, DateTime> namedDates;
  abstract final DateTime? isoDateTime;
  abstract final DateTime timestampDate;
  abstract final DateTime? parsedDate;

  _DateTimeTypesCopyWith get copyWith => _DateTimeTypesCopyWith._(this);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! DateTimeTypes) return false;

    if (createdAt != other.createdAt) {
      return false;
    }
    if (updatedAt != other.updatedAt) {
      return false;
    }
    if (birthDate != other.birthDate) {
      return false;
    }
    if (!DeepCollectionEquality().equals(eventDates, other.eventDates)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalEventDates, other.optionalEventDates)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(namedDates, other.namedDates)) {
      return false;
    }
    if (isoDateTime != other.isoDateTime) {
      return false;
    }
    if (timestampDate != other.timestampDate) {
      return false;
    }
    if (parsedDate != other.parsedDate) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      createdAt,
      updatedAt,
      birthDate,
      DeepCollectionEquality().hash(eventDates),
      DeepCollectionEquality().hash(optionalEventDates),
      DeepCollectionEquality().hash(namedDates),
      isoDateTime,
      timestampDate,
      parsedDate,
    ]);
  }

  @override
  String toString() {
    return 'DateTimeTypes(createdAt: $createdAt, updatedAt: $updatedAt, birthDate: $birthDate, eventDates: $eventDates, optionalEventDates: $optionalEventDates, namedDates: $namedDates, isoDateTime: $isoDateTime, timestampDate: $timestampDate, parsedDate: $parsedDate)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['createdAt'] = const DefaultDateTimeConverter().toJson(createdAt);
    if (updatedAt != null) {
      map['updatedAt'] = updatedAt != null
          ? const DefaultDateTimeConverter().toJson(updatedAt!)
          : null;
    }
    map['birth_date'] = const DefaultDateTimeConverter().toJson(birthDate);
    map['eventDates'] = eventDates;
    if (optionalEventDates != null) {
      map['optionalEventDates'] = optionalEventDates;
    }
    map['namedDates'] = namedDates;
    if (isoDateTime != null) {
      map['isoDateTime'] = isoDateTime != null
          ? const DefaultDateTimeConverter().toJson(isoDateTime!)
          : null;
    }
    map['timestampDate'] =
        const DefaultDateTimeConverter().toJson(timestampDate);
    if (parsedDate != null) {
      map['parsedDate'] = parsedDate != null
          ? const DefaultDateTimeConverter().toJson(parsedDate!)
          : null;
    }
    return map;
  }

  static DateTimeTypes fromJson(Map<String, dynamic> map) {
    final isoDateTimeReadValue = DateTimeTypes._readValue(map, 'isoDateTime');
    final timestampDateReadValue =
        DateTimeTypes._readValue(map, 'timestampDate');
    final parsedDateReadValue = DateTimeTypes._readValue(map, 'parsedDate');
    return DateTimeTypes(
      createdAt: map['createdAt'] != null
          ? const DefaultDateTimeConverter().fromJson(map['createdAt'])
              as DateTime
          : throw ArgumentError('Required field createdAt is missing'),
      updatedAt: map['updatedAt'] != null
          ? const DefaultDateTimeConverter().fromJson(map['updatedAt'])
          : null,
      birthDate: map['birth_date'] != null
          ? const DefaultDateTimeConverter().fromJson(map['birth_date'])
              as DateTime
          : throw ArgumentError('Required field birthDate is missing'),
      eventDates: (map['eventDates'] as List<dynamic>?)?.cast<DateTime>() ?? [],
      optionalEventDates:
          (map['optionalEventDates'] as List<dynamic>?)?.cast<DateTime>(),
      namedDates: (map['namedDates'] as Map<String, DateTime>?) ?? {},
      isoDateTime: isoDateTimeReadValue != null
          ? DateTime.tryParse(isoDateTimeReadValue.toString())
          : null,
      timestampDate: DateTime.parse((timestampDateReadValue ?? '').toString()),
      parsedDate: parsedDateReadValue != null
          ? DateTime.tryParse(parsedDateReadValue.toString())
          : null,
    );
  }
}

mixin _TimeZoneTest {
  abstract final DateTime utcTime;
  abstract final DateTime localTime;
  abstract final DateTime? timeZoneAware;
  abstract final List<DateTime> timeList;

  _TimeZoneTestCopyWith get copyWith => _TimeZoneTestCopyWith._(this);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! TimeZoneTest) return false;

    if (utcTime != other.utcTime) {
      return false;
    }
    if (localTime != other.localTime) {
      return false;
    }
    if (timeZoneAware != other.timeZoneAware) {
      return false;
    }
    if (!DeepCollectionEquality().equals(timeList, other.timeList)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      utcTime,
      localTime,
      timeZoneAware,
      DeepCollectionEquality().hash(timeList),
    ]);
  }

  @override
  String toString() {
    return 'TimeZoneTest(utcTime: $utcTime, localTime: $localTime, timeZoneAware: $timeZoneAware, timeList: $timeList)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['utcTime'] = const DefaultDateTimeConverter().toJson(utcTime);
    map['localTime'] = const DefaultDateTimeConverter().toJson(localTime);
    if (timeZoneAware != null) {
      map['timeZoneAware'] = timeZoneAware != null
          ? const DefaultDateTimeConverter().toJson(timeZoneAware!)
          : null;
    }
    map['timeList'] = timeList;
    return map;
  }

  static TimeZoneTest fromJson(Map<String, dynamic> map) {
    final timeZoneAwareReadValue =
        TimeZoneTest._readValue(map, 'timeZoneAware');
    return TimeZoneTest(
      utcTime: map['utcTime'] != null
          ? const DefaultDateTimeConverter().fromJson(map['utcTime'])
              as DateTime
          : throw ArgumentError('Required field utcTime is missing'),
      localTime: map['localTime'] != null
          ? const DefaultDateTimeConverter().fromJson(map['localTime'])
              as DateTime
          : throw ArgumentError('Required field localTime is missing'),
      timeZoneAware: timeZoneAwareReadValue != null
          ? DateTime.tryParse(timeZoneAwareReadValue.toString())
          : null,
      timeList: (map['timeList'] as List<dynamic>?)?.cast<DateTime>() ?? [],
    );
  }
}

/// Helper class for chained copyWith operations
class _DateTimeTypesCopyWith {
  final _DateTimeTypes _instance;
  const _DateTimeTypesCopyWith._(this._instance);

  /// Update createdAt field
  DateTimeTypes createdAt(DateTime? value) {
    return DateTimeTypes(
      createdAt: value ?? _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update updatedAt field
  DateTimeTypes updatedAt(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: value,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update birthDate field
  DateTimeTypes birthDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: value ?? _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update eventDates field
  DateTimeTypes eventDates(List<DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: value ?? _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update optionalEventDates field
  DateTimeTypes optionalEventDates(List<DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: value,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update namedDates field
  DateTimeTypes namedDates(Map<String, DateTime>? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: value ?? _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update isoDateTime field
  DateTimeTypes isoDateTime(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: value,
      timestampDate: _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update timestampDate field
  DateTimeTypes timestampDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: value ?? _instance.timestampDate,
      parsedDate: _instance.parsedDate,
    );
  }

  /// Update parsedDate field
  DateTimeTypes parsedDate(DateTime? value) {
    return DateTimeTypes(
      createdAt: _instance.createdAt,
      updatedAt: _instance.updatedAt,
      birthDate: _instance.birthDate,
      eventDates: _instance.eventDates,
      optionalEventDates: _instance.optionalEventDates,
      namedDates: _instance.namedDates,
      isoDateTime: _instance.isoDateTime,
      timestampDate: _instance.timestampDate,
      parsedDate: value,
    );
  }

  /// Traditional copyWith method
  DateTimeTypes call({
    DateTime? createdAt,
    DateTime? updatedAt,
    DateTime? birthDate,
    List<DateTime>? eventDates,
    List<DateTime>? optionalEventDates,
    Map<String, DateTime>? namedDates,
    DateTime? isoDateTime,
    DateTime? timestampDate,
    DateTime? parsedDate,
  }) {
    return DateTimeTypes(
      createdAt: createdAt ?? _instance.createdAt,
      updatedAt: updatedAt ?? _instance.updatedAt,
      birthDate: birthDate ?? _instance.birthDate,
      eventDates: eventDates ?? _instance.eventDates,
      optionalEventDates: optionalEventDates ?? _instance.optionalEventDates,
      namedDates: namedDates ?? _instance.namedDates,
      isoDateTime: isoDateTime ?? _instance.isoDateTime,
      timestampDate: timestampDate ?? _instance.timestampDate,
      parsedDate: parsedDate ?? _instance.parsedDate,
    );
  }
}

/// Helper class for chained copyWith operations
class _TimeZoneTestCopyWith {
  final _TimeZoneTest _instance;
  const _TimeZoneTestCopyWith._(this._instance);

  /// Update utcTime field
  TimeZoneTest utcTime(DateTime? value) {
    return TimeZoneTest(
      utcTime: value ?? _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: _instance.timeList,
    );
  }

  /// Update localTime field
  TimeZoneTest localTime(DateTime? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: value ?? _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: _instance.timeList,
    );
  }

  /// Update timeZoneAware field
  TimeZoneTest timeZoneAware(DateTime? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: value,
      timeList: _instance.timeList,
    );
  }

  /// Update timeList field
  TimeZoneTest timeList(List<DateTime>? value) {
    return TimeZoneTest(
      utcTime: _instance.utcTime,
      localTime: _instance.localTime,
      timeZoneAware: _instance.timeZoneAware,
      timeList: value ?? _instance.timeList,
    );
  }

  /// Traditional copyWith method
  TimeZoneTest call({
    DateTime? utcTime,
    DateTime? localTime,
    DateTime? timeZoneAware,
    List<DateTime>? timeList,
  }) {
    return TimeZoneTest(
      utcTime: utcTime ?? _instance.utcTime,
      localTime: localTime ?? _instance.localTime,
      timeZoneAware: timeZoneAware ?? _instance.timeZoneAware,
      timeList: timeList ?? _instance.timeList,
    );
  }
}
