// Generated by data class generator
// DO NOT MODIFY BY HAND

part of 'map_types.model.dart';

mixin _MapTypes {
  abstract final Map<String, String> stringMap;
  abstract final Map<String, int> intMap;
  abstract final Map<String, double> doubleMap;
  abstract final Map<String, bool> boolMap;
  abstract final Map<String, dynamic> dynamicMap;
  abstract final Map<String, String>? optionalStringMap;
  abstract final Map<String, List<String>> listMap;
  abstract final Map<String, Map<String, String>> nestedMap;
  abstract final Map<String, String> namedMap;
  abstract final Map<String, String>? parsedMap;
  abstract final Map<String, int> customIntMap;
  abstract final Map<String, Map<String, dynamic>>? complexMap;
  abstract final List<Map<String, String>> mapList;
  abstract final Map<int, String>? intKeyMap;

  _MapTypesCopyWith get copyWith => _MapTypesCopyWith._(this as MapTypes);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! MapTypes) return false;

    if (!DeepCollectionEquality().equals(stringMap, other.stringMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(intMap, other.intMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(doubleMap, other.doubleMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(boolMap, other.boolMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(dynamicMap, other.dynamicMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalStringMap, other.optionalStringMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(listMap, other.listMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(nestedMap, other.nestedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(namedMap, other.namedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(parsedMap, other.parsedMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(customIntMap, other.customIntMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(complexMap, other.complexMap)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(mapList, other.mapList)) {
      return false;
    }
    if (!DeepCollectionEquality().equals(intKeyMap, other.intKeyMap)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      DeepCollectionEquality().hash(stringMap),
      DeepCollectionEquality().hash(intMap),
      DeepCollectionEquality().hash(doubleMap),
      DeepCollectionEquality().hash(boolMap),
      DeepCollectionEquality().hash(dynamicMap),
      DeepCollectionEquality().hash(optionalStringMap),
      DeepCollectionEquality().hash(listMap),
      DeepCollectionEquality().hash(nestedMap),
      DeepCollectionEquality().hash(namedMap),
      DeepCollectionEquality().hash(parsedMap),
      DeepCollectionEquality().hash(customIntMap),
      DeepCollectionEquality().hash(complexMap),
      DeepCollectionEquality().hash(mapList),
      DeepCollectionEquality().hash(intKeyMap),
    ]);
  }

  @override
  String toString() {
    return 'MapTypes(stringMap: $stringMap, intMap: $intMap, doubleMap: $doubleMap, boolMap: $boolMap, dynamicMap: $dynamicMap, optionalStringMap: $optionalStringMap, listMap: $listMap, nestedMap: $nestedMap, namedMap: $namedMap, parsedMap: $parsedMap, customIntMap: $customIntMap, complexMap: $complexMap, mapList: $mapList, intKeyMap: $intKeyMap)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['stringMap'] = stringMap;
    map['intMap'] = intMap;
    map['doubleMap'] = doubleMap;
    map['boolMap'] = boolMap;
    map['dynamicMap'] = dynamicMap;
    if (optionalStringMap != null) {
      map['optionalStringMap'] = optionalStringMap;
    }
    map['listMap'] = listMap;
    map['nestedMap'] = nestedMap;
    map['str_map'] = namedMap;
    if (parsedMap != null) {
      map['parsedMap'] = parsedMap;
    }
    map['customIntMap'] = customIntMap;
    if (complexMap != null) {
      map['complexMap'] = complexMap;
    }
    map['mapList'] = mapList;
    if (intKeyMap != null) {
      map['intKeyMap'] = intKeyMap;
    }
    return map;
  }

  static MapTypes fromJson(Map<String, dynamic> map) {
    final parsedMapReadValue = MapTypes._readValue(map, 'parsedMap');
    final customIntMapReadValue = MapTypes._readValue(map, 'customIntMap');
    final complexMapReadValue = MapTypes._readValue(map, 'complexMap');
    return MapTypes(
      stringMap: (map['stringMap'] as Map<String, String>?) ?? {},
      intMap: (map['intMap'] as Map<String, int>?) ?? {},
      doubleMap: (map['doubleMap'] as Map<String, double>?) ?? {},
      boolMap: (map['boolMap'] as Map<String, bool>?) ?? {},
      dynamicMap: (map['dynamicMap'] as Map<String, dynamic>?) ?? {},
      optionalStringMap: (map['optionalStringMap'] as Map<String, String>?),
      listMap: (map['listMap'] as Map<String, dynamic>?)?.map((key, value) =>
              MapEntry(key, (value as List<dynamic>).cast<String>())) ??
          {},
      nestedMap: (map['nestedMap'] as Map<String, Map<String, String>>?) ?? {},
      namedMap: (map['str_map'] as Map<String, String>?) ?? {},
      parsedMap: parsedMapReadValue != null
          ? (parsedMapReadValue as Map?)?.cast<String, String>()
          : null,
      customIntMap: (customIntMapReadValue as Map?)?.cast<String, int>() ?? {},
      complexMap: complexMapReadValue != null
          ? (complexMapReadValue as Map?)?.cast<String, Map<String, dynamic>>()
          : null,
      mapList:
          (map['mapList'] as List<dynamic>?)?.cast<Map<String, String>>() ?? [],
      intKeyMap: (map['intKeyMap'] as Map<int, String>?),
    );
  }
}

mixin _MapWithObjects {
  abstract final Map<String, Address> addressMap;
  abstract final Map<String, List<Contact>> contactListMap;
  abstract final Map<String, Address>? optionalAddressMap;
  abstract final Map<String, Address>? parsedAddressMap;

  _MapWithObjectsCopyWith get copyWith =>
      _MapWithObjectsCopyWith._(this as MapWithObjects);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! MapWithObjects) return false;

    if (!DeepCollectionEquality().equals(addressMap, other.addressMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(contactListMap, other.contactListMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(optionalAddressMap, other.optionalAddressMap)) {
      return false;
    }
    if (!DeepCollectionEquality()
        .equals(parsedAddressMap, other.parsedAddressMap)) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      DeepCollectionEquality().hash(addressMap),
      DeepCollectionEquality().hash(contactListMap),
      DeepCollectionEquality().hash(optionalAddressMap),
      DeepCollectionEquality().hash(parsedAddressMap),
    ]);
  }

  @override
  String toString() {
    return 'MapWithObjects(addressMap: $addressMap, contactListMap: $contactListMap, optionalAddressMap: $optionalAddressMap, parsedAddressMap: $parsedAddressMap)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['addressMap'] = addressMap;
    map['contactListMap'] = contactListMap;
    if (optionalAddressMap != null) {
      map['optionalAddressMap'] = optionalAddressMap;
    }
    if (parsedAddressMap != null) {
      map['parsedAddressMap'] = parsedAddressMap;
    }
    return map;
  }

  static MapWithObjects fromJson(Map<String, dynamic> map) {
    final parsedAddressMapReadValue =
        MapWithObjects._readValue(map, 'parsedAddressMap');
    return MapWithObjects(
      addressMap: (map['addressMap'] as Map<String, dynamic>?)?.map((key,
                  value) =>
              MapEntry(key, Address.fromJson(value as Map<String, dynamic>))) ??
          {},
      contactListMap: (map['contactListMap'] as Map<String, dynamic>?)?.map(
              (key, value) => MapEntry(
                  key,
                  (value as List<dynamic>)
                      .map((item) =>
                          Contact.fromJson(item as Map<String, dynamic>))
                      .toList())) ??
          {},
      optionalAddressMap: (map['optionalAddressMap'] as Map<String, dynamic>?)
          ?.map((key, value) =>
              MapEntry(key, Address.fromJson(value as Map<String, dynamic>))),
      parsedAddressMap: parsedAddressMapReadValue != null
          ? (parsedAddressMapReadValue as Map?)?.cast<String, Address>()
          : null,
    );
  }
}

mixin _Address {
  abstract final String street;
  abstract final String city;
  abstract final String zipCode;

  _AddressCopyWith get copyWith => _AddressCopyWith._(this as Address);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Address) return false;

    if (street != other.street) {
      return false;
    }
    if (city != other.city) {
      return false;
    }
    if (zipCode != other.zipCode) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      street,
      city,
      zipCode,
    ]);
  }

  @override
  String toString() {
    return 'Address(street: $street, city: $city, zipCode: $zipCode)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['street'] = street;
    map['city'] = city;
    map['zipCode'] = zipCode;
    return map;
  }

  static Address fromJson(Map<String, dynamic> map) {
    return Address(
      street: SafeCasteUtil.safeCast<String>(map['street']) ?? "",
      city: SafeCasteUtil.safeCast<String>(map['city']) ?? "",
      zipCode: SafeCasteUtil.safeCast<String>(map['zipCode']) ?? "",
    );
  }
}

mixin _Contact {
  abstract final String email;
  abstract final String? phone;

  _ContactCopyWith get copyWith => _ContactCopyWith._(this as Contact);

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    if (other is! Contact) return false;

    if (email != other.email) {
      return false;
    }
    if (phone != other.phone) {
      return false;
    }
    return true;
  }

  @override
  int get hashCode {
    return Object.hashAll([
      email,
      phone,
    ]);
  }

  @override
  String toString() {
    return 'Contact(email: $email, phone: $phone)';
  }

  Map<String, dynamic> toJson() {
    final map = <String, dynamic>{};
    map['email'] = email;
    if (phone != null) {
      map['phone'] = phone;
    }
    return map;
  }

  static Contact fromJson(Map<String, dynamic> map) {
    return Contact(
      email: SafeCasteUtil.safeCast<String>(map['email']) ?? "",
      phone: SafeCasteUtil.safeCast<String>(map['phone']),
    );
  }
}

/// Helper class for chained copyWith operations
class _MapTypesCopyWith {
  final MapTypes _instance;
  const _MapTypesCopyWith._(this._instance);

  /// Update stringMap field
  _MapTypesCopyWith stringMap(Map<String, String> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: value,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update intMap field
  _MapTypesCopyWith intMap(Map<String, int> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: value,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update doubleMap field
  _MapTypesCopyWith doubleMap(Map<String, double> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: value,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update boolMap field
  _MapTypesCopyWith boolMap(Map<String, bool> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: value,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update dynamicMap field
  _MapTypesCopyWith dynamicMap(Map<String, dynamic> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: value,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update optionalStringMap field
  _MapTypesCopyWith optionalStringMap(Map<String, String>? value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: value,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update listMap field
  _MapTypesCopyWith listMap(Map<String, List<String>> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: value,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update nestedMap field
  _MapTypesCopyWith nestedMap(Map<String, Map<String, String>> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: value,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update namedMap field
  _MapTypesCopyWith namedMap(Map<String, String> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: value,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update parsedMap field
  _MapTypesCopyWith parsedMap(Map<String, String>? value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: value,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update customIntMap field
  _MapTypesCopyWith customIntMap(Map<String, int> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: value,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update complexMap field
  _MapTypesCopyWith complexMap(Map<String, Map<String, dynamic>>? value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: value,
      mapList: _instance.mapList,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update mapList field
  _MapTypesCopyWith mapList(List<Map<String, String>> value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: value,
      intKeyMap: _instance.intKeyMap,
    ));
  }

  /// Update intKeyMap field
  _MapTypesCopyWith intKeyMap(Map<int, String>? value) {
    return _MapTypesCopyWith._(MapTypes(
      stringMap: _instance.stringMap,
      intMap: _instance.intMap,
      doubleMap: _instance.doubleMap,
      boolMap: _instance.boolMap,
      dynamicMap: _instance.dynamicMap,
      optionalStringMap: _instance.optionalStringMap,
      listMap: _instance.listMap,
      nestedMap: _instance.nestedMap,
      namedMap: _instance.namedMap,
      parsedMap: _instance.parsedMap,
      customIntMap: _instance.customIntMap,
      complexMap: _instance.complexMap,
      mapList: _instance.mapList,
      intKeyMap: value,
    ));
  }

  /// Build the final instance
  MapTypes build() {
    return _instance;
  }

  /// Traditional copyWith method
  MapTypes call({
    Map<String, String>? stringMap,
    Map<String, int>? intMap,
    Map<String, double>? doubleMap,
    Map<String, bool>? boolMap,
    Map<String, dynamic>? dynamicMap,
    Map<String, String>? optionalStringMap,
    Map<String, List<String>>? listMap,
    Map<String, Map<String, String>>? nestedMap,
    Map<String, String>? namedMap,
    Map<String, String>? parsedMap,
    Map<String, int>? customIntMap,
    Map<String, Map<String, dynamic>>? complexMap,
    List<Map<String, String>>? mapList,
    Map<int, String>? intKeyMap,
  }) {
    return MapTypes(
      stringMap: stringMap ?? _instance.stringMap,
      intMap: intMap ?? _instance.intMap,
      doubleMap: doubleMap ?? _instance.doubleMap,
      boolMap: boolMap ?? _instance.boolMap,
      dynamicMap: dynamicMap ?? _instance.dynamicMap,
      optionalStringMap: optionalStringMap ?? _instance.optionalStringMap,
      listMap: listMap ?? _instance.listMap,
      nestedMap: nestedMap ?? _instance.nestedMap,
      namedMap: namedMap ?? _instance.namedMap,
      parsedMap: parsedMap ?? _instance.parsedMap,
      customIntMap: customIntMap ?? _instance.customIntMap,
      complexMap: complexMap ?? _instance.complexMap,
      mapList: mapList ?? _instance.mapList,
      intKeyMap: intKeyMap ?? _instance.intKeyMap,
    );
  }
}

/// Helper class for chained copyWith operations
class _MapWithObjectsCopyWith {
  final MapWithObjects _instance;
  const _MapWithObjectsCopyWith._(this._instance);

  /// Update addressMap field
  _MapWithObjectsCopyWith addressMap(Map<String, Address> value) {
    return _MapWithObjectsCopyWith._(MapWithObjects(
      addressMap: value,
      contactListMap: _instance.contactListMap,
      optionalAddressMap: _instance.optionalAddressMap,
      parsedAddressMap: _instance.parsedAddressMap,
    ));
  }

  /// Update contactListMap field
  _MapWithObjectsCopyWith contactListMap(Map<String, List<Contact>> value) {
    return _MapWithObjectsCopyWith._(MapWithObjects(
      addressMap: _instance.addressMap,
      contactListMap: value,
      optionalAddressMap: _instance.optionalAddressMap,
      parsedAddressMap: _instance.parsedAddressMap,
    ));
  }

  /// Update optionalAddressMap field
  _MapWithObjectsCopyWith optionalAddressMap(Map<String, Address>? value) {
    return _MapWithObjectsCopyWith._(MapWithObjects(
      addressMap: _instance.addressMap,
      contactListMap: _instance.contactListMap,
      optionalAddressMap: value,
      parsedAddressMap: _instance.parsedAddressMap,
    ));
  }

  /// Update parsedAddressMap field
  _MapWithObjectsCopyWith parsedAddressMap(Map<String, Address>? value) {
    return _MapWithObjectsCopyWith._(MapWithObjects(
      addressMap: _instance.addressMap,
      contactListMap: _instance.contactListMap,
      optionalAddressMap: _instance.optionalAddressMap,
      parsedAddressMap: value,
    ));
  }

  /// Build the final instance
  MapWithObjects build() {
    return _instance;
  }

  /// Traditional copyWith method
  MapWithObjects call({
    Map<String, Address>? addressMap,
    Map<String, List<Contact>>? contactListMap,
    Map<String, Address>? optionalAddressMap,
    Map<String, Address>? parsedAddressMap,
  }) {
    return MapWithObjects(
      addressMap: addressMap ?? _instance.addressMap,
      contactListMap: contactListMap ?? _instance.contactListMap,
      optionalAddressMap: optionalAddressMap ?? _instance.optionalAddressMap,
      parsedAddressMap: parsedAddressMap ?? _instance.parsedAddressMap,
    );
  }
}

/// Helper class for chained copyWith operations
class _AddressCopyWith {
  final Address _instance;
  const _AddressCopyWith._(this._instance);

  /// Update street field
  _AddressCopyWith street(String value) {
    return _AddressCopyWith._(Address(
      street: value,
      city: _instance.city,
      zipCode: _instance.zipCode,
    ));
  }

  /// Update city field
  _AddressCopyWith city(String value) {
    return _AddressCopyWith._(Address(
      street: _instance.street,
      city: value,
      zipCode: _instance.zipCode,
    ));
  }

  /// Update zipCode field
  _AddressCopyWith zipCode(String value) {
    return _AddressCopyWith._(Address(
      street: _instance.street,
      city: _instance.city,
      zipCode: value,
    ));
  }

  /// Build the final instance
  Address build() {
    return _instance;
  }

  /// Traditional copyWith method
  Address call({
    String? street,
    String? city,
    String? zipCode,
  }) {
    return Address(
      street: street ?? _instance.street,
      city: city ?? _instance.city,
      zipCode: zipCode ?? _instance.zipCode,
    );
  }
}

/// Helper class for chained copyWith operations
class _ContactCopyWith {
  final Contact _instance;
  const _ContactCopyWith._(this._instance);

  /// Update email field
  _ContactCopyWith email(String value) {
    return _ContactCopyWith._(Contact(
      email: value,
      phone: _instance.phone,
    ));
  }

  /// Update phone field
  _ContactCopyWith phone(String? value) {
    return _ContactCopyWith._(Contact(
      email: _instance.email,
      phone: value,
    ));
  }

  /// Build the final instance
  Contact build() {
    return _instance;
  }

  /// Traditional copyWith method
  Contact call({
    String? email,
    String? phone,
  }) {
    return Contact(
      email: email ?? _instance.email,
      phone: phone ?? _instance.phone,
    );
  }
}
